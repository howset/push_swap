#Notes

## Organization
1. All files in ./src
2. Allowed operations are in 
## General
1. ==main== The `main` function in push_swap.c first checks for valid arguments by calling `ft_argcheck` in utils_checks.c. This function is responsible for splitting the input to args if necessary by using `ft_split` (from libft). Then it checks if the args are all valid numbers (`ft_isnbr`), if not, then error are printed by the function `ft_prt_err` in utils_free+print.c. Duplicates are checked with `ft_isdupli`. If `ft_split` is utilized, then due to memory allocation, <kbd>args</kbd> has to be freed.
2. <mark>main</mark> Then the <kbd>stacks a & b</kbd> are allocated by malloc. The stacks' structure are declared in the header file, which is a singly linked list that contains an index (to determine the most efficient sequence of operations to sort the stack -e.g., if an element is far from its correct position in the sorted stack (i.e., its index is far from its value), it might be more efficient to use a series of rotates or reverse rotates to move it to its correct position, rather than using a series of pushes and swaps.). <kbd>stack a</kbd> is initialized by the function `stack_init` in push_swap.c.
3. <mark>stack_init</mark> The declared variable <kbd>args</kbd> contains all the arguments. The loop creates a new node by calling the function `ft_lst_newnode` (in utils_list.c) and adds it to the back of the stack by the using the function `ft_lst_nodeback`.
	- The `ft_lst_newnode` function adds the value to the newly created node, assigns the <kbd>index</kbd> value at -1 (sentinel value, real value will be set by the function `index_stack`) and set the <kbd>next</kbd> pointer of the stack to NULL. The `ft_lst_node2back` checks if the stack is empty or not. If it is empty, it makes the <kbd>new_node</kbd> as the first node. If it is not empty, then it calls the `ft_lst_pointer2last` to get the pointer to the last node in the stack. Then the `ft_lst_node2back` sets the <kbd>next</kbd> field of the last node in the stack to the <kbd>new_node</kbd>, and the <kbd>next</kbd> field of the <kbd>new_node</kbd> to NULL.
4. </mark>[index_stack]</mark> Then after the stack has been populated by the values, the function `index_stack` (in utils_index.c) assigns the proper indexes. This function relies on the function `get_next_min` which the node with the smallest value in a stack that has not been indexed. The `get_next_min` function loops to check each node. if the <kbd>index</kbd> of a node is -1 and do not have the  <kbd>flag</kbd>, then it is at position 1. The flag is then set to 1 and <kbd>min</kbd> as <kbd>head</kbd>. The next node is then checked if not yet indexed (-1), and checked if the <kbd>value</kbd> is less then the previous node. 
Basically, if the array is {3, 1, 2, 4}, the index would be 2, 0, 1, 3, respectively. (!!!!)
5. <mark></mark>